package App::Croon::Cron;
use strict;
use warnings;
use utf8;
use Carp;

use constant WEEKDAY_MAP => {
    sun => 0,
    mon => 1,
    tue => 2,
    wed => 3,
    thu => 4,
    fri => 5,
    sat => 6,
};

use constant MONTH_MAP => {
    jan => 1,
    feb => 2,
    mar => 3,
    apr => 4,
    may => 5,
    jun => 6,
    jul => 7,
    aug => 8,
    sep => 9,
    oct => 10,
    nov => 11,
    dec => 12,
};

sub translate_from_obj {
    my ($obj) = @_;

    my $min  = _format($obj->{min});
    my $hour = _format($obj->{hour});
    if (my $time = $obj->{time}) {
        ($hour, $min) = map { int $_ } split(/:/, $time);
    }
    my $day     = _format($obj->{day});
    my $month   = ( $obj->{month} && MONTH_MAP->{lcfirst($obj->{month})} ) || _format($obj->{month});
    my $w_day   = ( $obj->{w_day} && WEEKDAY_MAP->{lcfirst($obj->{w_day})} ) || _format($obj->{w_day});
    my $command = _escape_command($obj->{command});
    my $name    = $obj->{name} or croak '[Error] Name is not specified';

    # log
    my $stdout_log = $obj->{stdout_log};
    my $stderr_log = $obj->{stderr_log};
    if ($stdout_log && $stderr_log) {
        $command = ($stdout_log eq $stderr_log) ? "$command >$stdout_log 2>&1"
                                                : "$command 1>$stdout_log 2>$stderr_log";
    }
    elsif ($stderr_log) {
        $command = "$command 2>$stderr_log";
    }
    elsif ($stdout_log) {
        $command = "$command 1>$stdout_log";
    }

    # exclusive by time range
    if (my $exclusion = $obj->{exclusion}) {
        my $from = $exclusion->{from};
        my $to = $exclusion->{to};
        croak '[Error] Invalid exclusion date range is specified' if (!$from || !$to);
        $from =~ s/://g;
        $to   =~ s/://g;
        $command = 'now=`date +"%H%M%S"`' . sprintf(' && if ([ %s -le $now ] && [ $now -le %s ]) ; then : ; else %s ; fi', $from, $to, $command);
    }

    my $cron = sprintf(<<'EOC', $name, $min, $hour, $day, $month, $w_day, $command, $name);
# %s: this cron was generated by Croon {{{
%s %s %s %s %s %s
# }}} %s
EOC
    return $cron;
}

sub _escape_command {
    my ($command) = @_;

    croak '[Error] Command is not specified' unless $command;

    $command =~ s/%/\\%/g;
    return $command;
}

sub _format {
    my ($date_or_time) = @_;

    return '*' unless defined($date_or_time);
    if (my ($tick) = ($date_or_time  =~ /every (\d+)/)) {
        $date_or_time = "*/$tick";
    }
    return $date_or_time;
}

1;
